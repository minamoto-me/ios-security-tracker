import { Env, ProcessingLog, Vulnerability } from '../types';
import { VulnerabilityRepository } from '../database/repository';
import { AppleSecurityParser } from './apple-security-parser';
import { NVDClient } from './nvd-client';

export class VulnerabilityScanner {
  private env: Env;
  private repository: VulnerabilityRepository;
  private nvdClient: NVDClient;

  constructor(env: Env) {
    this.env = env;
    this.repository = new VulnerabilityRepository(env);
    this.nvdClient = new NVDClient(env);
  }

  async runWeeklyVulnerabilityScan(): Promise<{
    vulnerabilities_found: number;
    vulnerabilities_new: number;
    vulnerabilities_updated: number;
    ios_releases_processed: number;
  }> {
    const startTime = Date.now();
    let vulnerabilities_found = 0;
    let vulnerabilities_new = 0;
    let vulnerabilities_updated = 0;
    let ios_releases_processed = 0;
    const errors: string[] = [];

    try {
      console.log('Starting weekly vulnerability scan...');

      // Get recent iOS security releases
      const securityReleases = await this.fetchRecentIOSSecurityReleases();
      console.log(`Found ${securityReleases.length} iOS security releases to process`);

      for (const release of securityReleases) {
        try {
          console.log(`Processing iOS ${release.version}...`);

          // Check if this release was already processed
          const existingRelease = await this.repository.getIOSReleaseByVersion(release.version);
          if (existingRelease) {
            console.log(`iOS ${release.version} already processed, skipping`);
            continue;
          }

          // Insert iOS release record
          const releaseId = await this.repository.insertIOSRelease({
            version: release.version,
            release_date: release.releaseDate,
            security_content_url: `${this.env.APPLE_SECURITY_BASE_URL}/HT213000`, // Placeholder
          });

          ios_releases_processed++;

          // Process vulnerabilities in this release
          for (const vuln of release.vulnerabilities) {
            try {
              vulnerabilities_found++;

              // Check if vulnerability already exists
              const existingVuln = await this.repository.getVulnerabilityByCveId(vuln.cveId);

              let cvssData = null;
              let description = vuln.description;

              // Only fetch from NVD if this is a new vulnerability to save rate limits
              if (!existingVuln) {
                // Get CVSS data from NVD
                cvssData = await this.nvdClient.getCVSSData(vuln.cveId);

                // Get enhanced description from NVD if available
                const nvdDescription = await this.nvdClient.getCVEDescription(vuln.cveId);
                description = nvdDescription || vuln.description;
              } else {
                // For existing vulnerabilities, update them with new Apple context if available
                cvssData = {
                  score: existingVuln.cvss_score,
                  vector: existingVuln.cvss_vector,
                  severity: existingVuln.severity
                };
                description = existingVuln.description;
                console.log(`Updating existing CVE ${vuln.cveId} with Apple context`);
              }

              // Determine iOS versions affected
              const iosVersionsAffected = release.version;

              const inferredSeverity = this.inferSeverityFromDescription(description);
              const vulnerability: Omit<Vulnerability, 'created_at'> = {
                id: vuln.cveId,
                cve_id: vuln.cveId,
                description: description || 'Security vulnerability addressed in this update.',
                severity: cvssData?.severity || inferredSeverity || 'MEDIUM',
                cvss_score: (cvssData?.score !== undefined) ? cvssData.score : null,
                cvss_vector: cvssData?.vector || null,
                ios_versions_affected: iosVersionsAffected || 'Unknown',
                discovered_date: release.releaseDate || new Date().toISOString().split('T')[0],
                apple_description: vuln.appleDescription,
                apple_available_for: vuln.availableFor,
                apple_impact: vuln.impact,
                apple_product: vuln.product,
              };

              if (existingVuln) {
                // Update existing vulnerability
                await this.repository.insertVulnerability(vulnerability);
                vulnerabilities_updated++;
                console.log(`Updated CVE ${vuln.cveId}`);
              } else {
                // Insert new vulnerability
                await this.repository.insertVulnerability(vulnerability);
                vulnerabilities_new++;
                console.log(`Added new CVE ${vuln.cveId} with CVSS ${cvssData?.score || 'N/A'}`);
              }

              // Link vulnerability to iOS release
              await this.repository.linkVulnerabilityToRelease(vuln.cveId, releaseId);

            } catch (error) {
              const errorMsg = `Failed to process CVE ${vuln.cveId}: ${error}`;
              console.error(errorMsg);
              errors.push(errorMsg);
            }
          }

        } catch (error) {
          const errorMsg = `Failed to process iOS release ${release.version}: ${error}`;
          console.error(errorMsg);
          errors.push(errorMsg);
        }
      }

      const result = {
        vulnerabilities_found,
        vulnerabilities_new,
        vulnerabilities_updated,
        ios_releases_processed,
      };

      // Log successful processing
      await this.logProcessingResult({
        status: errors.length > 0 ? 'PARTIAL' : 'SUCCESS',
        vulnerabilities_found,
        vulnerabilities_new,
        vulnerabilities_updated,
        ios_releases_processed,
        execution_time_ms: Date.now() - startTime,
        errors: errors.length > 0 ? errors.join('; ') : null,
      });

      console.log('Weekly vulnerability scan completed:', result);
      return result;

    } catch (error) {
      const errorMsg = `Vulnerability scan failed: ${error}`;
      console.error(errorMsg);

      // Log failure
      await this.logProcessingResult({
        status: 'FAILED',
        vulnerabilities_found,
        vulnerabilities_new,
        vulnerabilities_updated,
        ios_releases_processed,
        execution_time_ms: Date.now() - startTime,
        errors: errorMsg,
      });

      throw error;
    }
  }

  async logProcessingResult(log: Omit<ProcessingLog, 'id' | 'run_date'>): Promise<void> {
    try {
      await this.repository.insertProcessingLog(log);
    } catch (error) {
      console.error('Failed to log processing result:', error);
    }
  }

  private async fetchRecentIOSSecurityReleases() {
    try {
      // Fetch Apple's main security releases page
      const response = await fetch(`${this.env.APPLE_SECURITY_BASE_URL}/en-us/100100`, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        },
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch Apple security releases: ${response.status}`);
      }

      const html = await response.text();

      // Extract iOS security release links
      const iosReleases = this.extractIOSReleaseLinks(html);

      // Fetch details for each release
      const securityReleases = [];
      for (const release of iosReleases.slice(0, 5)) { // Limit to 5 most recent
        try {
          const releaseDetails = await this.fetchIOSReleaseDetails(release.url, release.version);
          if (releaseDetails && releaseDetails.vulnerabilities.length > 0) {
            securityReleases.push(releaseDetails);
          }
        } catch (error) {
          console.error(`Failed to fetch details for iOS ${release.version}:`, error);
        }
      }

      return securityReleases;

    } catch (error) {
      console.error('Failed to fetch iOS security releases:', error);
      return [];
    }
  }

  private extractIOSReleaseLinks(html: string): Array<{ version: string; url: string }> {
    const releases: Array<{ version: string; url: string }> = [];

    // The main security page contains a table with links to individual iOS version security pages
    // Look for table rows that contain iOS version links
    const patterns = [
      // Pattern for iOS/iPadOS links in table format: <a href="/en-us/HT123456">iOS 17.1 and iPadOS 17.1</a>
      /<a[^>]+href="([^"]*\/en-us\/HT\d+[^"]*)"[^>]*>([^<]*iOS\s+(\d+(?:\.\d+)*)[^<]*)</gi,
      // Alternative pattern for standalone iOS links
      /<a[^>]+href="([^"]*\/en-us\/\d+[^"]*)"[^>]*>([^<]*iOS\s+(\d+(?:\.\d+)*)[^<]*)</gi,
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(html)) !== null) {
        const relativeUrl = match[1];
        const fullText = match[2];
        const version = match[3];

        // Convert relative URL to absolute
        const url = relativeUrl.startsWith('http') ? relativeUrl : `${this.env.APPLE_SECURITY_BASE_URL}${relativeUrl}`;

        if (version && this.isValidIOSVersion(version)) {
          console.log(`Found iOS security page: ${fullText} -> ${url}`);
          releases.push({ version, url });
        }
      }
    }

    // Also look for any HT-prefixed security bulletins that might contain iOS
    const htPattern = /<a[^>]+href="([^"]*\/en-us\/HT\d+[^"]*)"[^>]*>([^<]*)</gi;
    let htMatch;
    while ((htMatch = htPattern.exec(html)) !== null) {
      const relativeUrl = htMatch[1];
      const linkText = htMatch[2];

      // Check if this link text mentions iOS
      const iosVersionMatch = linkText.match(/iOS\s+(\d+(?:\.\d+)*)/i);
      if (iosVersionMatch) {
        const version = iosVersionMatch[1];
        const url = relativeUrl.startsWith('http') ? relativeUrl : `${this.env.APPLE_SECURITY_BASE_URL}${relativeUrl}`;

        if (this.isValidIOSVersion(version)) {
          console.log(`Found iOS HT security page: ${linkText} -> ${url}`);
          releases.push({ version, url });
        }
      }
    }

    // Remove duplicates and sort by version (newest first)
    const uniqueReleases = releases.reduce((acc, release) => {
      if (!acc.find(r => r.version === release.version && r.url === release.url)) {
        acc.push(release);
      }
      return acc;
    }, [] as Array<{ version: string; url: string }>);

    console.log(`Extracted ${uniqueReleases.length} unique iOS security releases`);
    return uniqueReleases.sort((a, b) => this.compareVersions(b.version, a.version));
  }

  private async fetchIOSReleaseDetails(url: string, version: string) {
    try {
      console.log(`Fetching details for iOS ${version} from ${url}`);

      const response = await fetch(url, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        },
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status}`);
      }

      const html = await response.text();
      const securityRelease = AppleSecurityParser.parseSecurityContent(html, version);

      if (!AppleSecurityParser.validateSecurityRelease(securityRelease)) {
        console.warn(`Invalid security release data for iOS ${version}`);
        return null;
      }

      return securityRelease;

    } catch (error) {
      console.error(`Failed to fetch iOS release details for ${version}:`, error);
      return null;
    }
  }

  private isValidIOSVersion(version: string): boolean {
    return /^\d+(?:\.\d+)*$/.test(version) && parseFloat(version) >= 13.0;
  }

  private compareVersions(a: string, b: string): number {
    const aParts = a.split('.').map(Number);
    const bParts = b.split('.').map(Number);
    const maxLength = Math.max(aParts.length, bParts.length);

    for (let i = 0; i < maxLength; i++) {
      const aPart = aParts[i] || 0;
      const bPart = bParts[i] || 0;

      if (aPart > bPart) return 1;
      if (aPart < bPart) return -1;
    }

    return 0;
  }

  private inferSeverityFromDescription(description: string): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    const lowerDesc = description.toLowerCase();

    if (lowerDesc.includes('remote code execution') ||
        lowerDesc.includes('arbitrary code execution') ||
        lowerDesc.includes('privilege escalation') ||
        lowerDesc.includes('kernel')) {
      return 'CRITICAL';
    }

    if (lowerDesc.includes('memory corruption') ||
        lowerDesc.includes('buffer overflow') ||
        lowerDesc.includes('use after free') ||
        lowerDesc.includes('sandbox escape')) {
      return 'HIGH';
    }

    if (lowerDesc.includes('information disclosure') ||
        lowerDesc.includes('denial of service') ||
        lowerDesc.includes('bypass')) {
      return 'MEDIUM';
    }

    return 'MEDIUM'; // Default fallback
  }
}